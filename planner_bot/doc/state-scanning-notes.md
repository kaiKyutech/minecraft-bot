## State Scanning Notes

2024-**TODO**-**TODO**

このメモは `state_manager.refresh` の実装変更（`findBlock` → `scanBlocks` ベース）に伴う気付きと調査結果をまとめたものです。

### 背景

- もともと `refresh` は `state_schema.yaml` に定義された各 `nearby_*` 状態ごとに Mineflayer の `bot.findBlock` / `findBlockCategory` を呼び、ヒットした時点で探索を打ち切る構造だった。
- `findBlock` は個々の判定には軽いが、対象が増えるほど一つずつ距離検索を繰り返すため、特に「見つからない」ケースでは半径 100 ブロック全体を複数回スキャンすることになり負荷が高かった。
- `scanBlocks` を `refresh` に流用することで、半径 100 の球領域（上下方向も含む）をまとめて走査し、カテゴリ判定を一度に済ませられるようになった（`collectBlocks:false`で配列生成を抑制）。

### 現状の挙動

- `STATE_SCAN_RANGE`（既定 100）と `STATE_SCAN_MAX_CHECKS`（既定で無制限扱い）を環境変数で調整可能。
- `scanBlocks` は走査順序を現在位置中心のスパイラル順に並べ替え、該当ブロックを見つけた時点で `onBlock` コールバックから `true` を返すことでスキャンを打ち切れる。
- `refresh` ではカテゴリ／個別ブロックごとの最大距離を算出し、その範囲で `scanBlocks` を実行。見つかった時点で各 `nearby_*` を真に設定する。

### 気付き

- `scanBlocks` に `maxChecks` をデフォルト値（25,000）で渡すと、探索が早期に打ち切られ周囲のブロックを取りこぼすケースがある。GOAP 前提条件が全て false に落ち、プラン生成が即失敗するリスクが高い。
- `maxChecks` に `-1`（無制限）を渡すことで、既存の `!info scanBlocks` コマンドと同じ挙動になり、環境状態も安定して感知できた。パフォーマンス面は `range:100` でも ~40ms 程度で収束。
- `scanBlocks` を `refresh` に組み込んでも GOAP 実行前後の `refresh` 呼び出しは従来通りに動作し、追加のインターフェイス変更は不要。
- `gather` 実行直前の「本当に採れるか」確認には依然として `findBlock` を使うことを推奨。`scanBlocks` は状態推定に向き、実行フェーズでの最終確認は `findBlock` のほうが確実。
- `scanBlocks` の生結果には半径内の全ブロック位置と種類が含まれるため、これをキャッシュすれば「近隣の資源座標リスト」を構築できる。`refresh` ごとに再スキャンするのではなく、必要に応じて部分更新したり、`gather` 実行時の最寄り候補を先に提示するなど、GOAP の再計画回数削減につながる余地がある。
- `findBlock` は単一判定でも意外とコストが高いため、キャッシュ済みの座標から距離順にアクセスし、`bot.blockAt` で最終確認するワークフローに切り替えれば、`findBlock` 連発を減らせる可能性が高い。`scanBlocks` で得たリストを一定時間保持し、無効化条件（ブロック破壊など）とセットで管理する案を検討したい。
- `gather` スキル内では、カテゴリ指定のときに「どのブロック種類が最も近かったか」だけを `blockSelectionCache` に記録しており、座標まではキャッシュしていない。実際の採取対象は毎回 `findBlocks`（デフォルト 5件）で取り直し、距離順に並べ替えて利用する設計になっている（失敗座標は回避リストに追加）。

### 今後の検討

- `scanBlocks` の結果サマリから距離や個数を集計して保管しておくと、L2 の意思決定やリソースレーダーに活用できそう。
- Y 方向の範囲（`minYOffset` / `maxYOffset`）を環境に合わせて調整すると無駄なチェック数が減り、パフォーマンス最適化につながる。
- 複数ボット運用時はスキャン結果のキャッシュや更新間隔を調整し、`refresh` 呼び出しのたびにフルスキャンを行わない作りも検討したい。
- primitives.jsにおいてfindBlocksの時間測っているところがある。これがいらないなら消した方が最適化するかもしれない。